#### Informix node.js with N-API
Current state:  Experimental


### build
```bash
<<<<<<< HEAD
git clone https://github.com/OpenInformix/IfxNode2.git
cd IfxNode2
=======
npm install odbc
```
---

## Important Changes in 2.0

`node-odbc` has recently been upgraded from its initial release. The following list highlights the major improvements and potential code-breaking changes.

* **Promise support:** All asynchronous functions can now be used with native JavaScript Promises. If a callback function is not passed, the ODBC functions will return a native Promise. If a callback _is_ passed to the ODBC functions, then the old callback behavior will be used.

* **Performance improvements:** The underlying ODBC function calls have been reworked to greatly improve performance. For ODBC afficianados, `node-odbc` used to retrieved results using SQLGetData, which works for small amounts of data but is slow for large datasets. `node-odbc` now uses SQLBindCol for binding result sets, which for large queries is orders of magnitude faster.

* **Rewritten with N-API:** `node-odbc` was completely rewritten using node-addon-api, a C++ wrapper for N-API, which created an engine-agnostic and ABI-stable package. This means that if you upgrade your Node.js version, there is no need to recompile the package, it just works!

* **API Changes:** The API has been changed and simplified. See the documentation below for a list of all the changes.

---

## API

* [Connection](#Connection)
    * [constructor (new Connection())](#constructor-new-connectionconnectionstring)
    * [.query()](#querysql-parameters-callback)
    * [.callProcedure()](#callprocedurecatalog-schema-name-parameters-callback)
    * [.createStatement()](#createstatementcallback)
    * [.tables()](#tablescatalog-schema-table-type-callback)
    * [.columns()](#columnscatalog-schema-table-column-callback)
    * [.beginTransaction()](#begintransactioncallback)
    * [.commit()](#commitcallback)
    * [.rollback()](#rollbackcallback)
    * [.close()](#closecallback)
* [Pool](#Pool)
    * [constructor (new Pool())](#constructor-new-poolconnectionstring)
    * [.init()](#initcallback)
    * [.connect()](#connectcallback)
    * [.query()](#querysql-parameters-callback-1)
    * [.close()](#closecallback-1)
* [Statement](#Statement)
    * [.prepare()](#preparesql-callback)
    * [.bind()](#bindparameters-callback)
    * [.execute()](#executecallback)
    * [.close()](#closecallback-2)

### **Callbacks _or_ Promises**

Every asynchronous function in the Node.js `node-odbc` package can be called with either a callback Function or a Promise. To use Promises, simply do not pass a callback function (in the API docs below, specified with a `callback?`). This will return a Promise object than can then be used with `.then` or the more modern `async/await` workflow. To use callbacks, simply pass a callback function. For each function explained in the documents below, both Callback and Promise examples are given.

_All examples are shown using IBM i Db2 DSNs and queries. Because ODBC is DBMS-agnostic, examples will work as long as the query strings are modified for your particular DBMS._

### **Result Array**

All functions that return a result set do so in an array, where each row in the result set is an entry in the array. The format of data within the row can either be an array or an object, depending on the configuration option passed to the connection.

The result array also contains several properties:
* `count`: the number of rows affected by the statement or procedure. Returns the result from ODBC function SQLRowCount.
* `columns`: a list of columns in the result set. This is returned in an array. Each column in the array has the following properties:
  * `name`: The name of the column
  * `dataType`: The data type of the column properties
* `statement`: The statement used to return the result set
* `parameters`: The parameters passed to the statement or procedure. For input/output and output parameters, this value will reflect the value updated from a procedure. 
* `return`: The return value from some procedures. For many DBMS, this will always be undefined.

```
[ { CUSNUM: 938472,
    LSTNAM: 'Henning ',
    INIT: 'G K',
    STREET: '4859 Elm Ave ',
    CITY: 'Dallas',
    STATE: 'TX',
    ZIPCOD: 75217,
    CDTLMT: 5000,
    CHGCOD: 3,
    BALDUE: 37,
    CDTDUE: 0 },
  { CUSNUM: 839283,
    LSTNAM: 'Jones   ',
    INIT: 'B D',
    STREET: '21B NW 135 St',
    CITY: 'Clay  ',
    STATE: 'NY',
    ZIPCOD: 13041,
    CDTLMT: 400,
    CHGCOD: 1,
    BALDUE: 100,
    CDTDUE: 0 },
  statement: 'SELECT * FROM QIWS.QCUSTCDT',
  parameters: [],
  return: undefined,
  count: -1,
  columns: [ { name: 'CUSNUM', dataType: 2 },
    { name: 'LSTNAM', dataType: 1 },
    { name: 'INIT', dataType: 1 },
    { name: 'STREET', dataType: 1 },
    { name: 'CITY', dataType: 1 },
    { name: 'STATE', dataType: 1 },
    { name: 'ZIPCOD', dataType: 2 },
    { name: 'CDTLMT', dataType: 2 },
    { name: 'CHGCOD', dataType: 2 },
    { name: 'BALDUE', dataType: 2 },
    { name: 'CDTDUE', dataType: 2 } ] ]
```

In this example, two rows are returned, with eleven columns each. The format of these columns is found on the `columns` property, with their names and dataType (which are integers mapped to SQL data types).

With this result structure, users can iterate over the result set like any old array (in this case, `results.length` would return 2) while also accessing important information from the SQL call and result set.

---
---

## **Connection**

Connection has the following functions:

### `constructor (new Connection(connectionString))`

Create a Connection object, which is opened (synchronously!)

```javascript
const { Connection } = require('odbc');
const connection = new Connection(connectionString);
```

---

### `.query(sql, parameters?, callback?)`

Run a query on the database. Can be passed an SQL string with parameter markers `?` and an array of parameters to bind to those markers. 

```JavaScript
const { Connection } = require('odbc');
const connection = new Connection(connectionString);
connection.query('SELECT * FROM QIWS.QCUSTCDT', (error, result) => {
    if (error) { console.error(error) }
    console.log(result);
})
```

---

### `.callProcedure(catalog, schema, name, parameters?, callback?)`

Calls a database procedure, returning the results in a [result array](#result-array).

#### Parameters:
* **catalog**: The name of the catalog where the procedure exists, or null to use the default catalog
* **schema**: The name of the schema where the procedure exists, or null to use a default schema
* **name**: The name of the procedure in the database
* **{OPTIONAL} parameters**: An array of parameters to pass to the procedure. For input and input/output parameters, the JavaScript value passed in is expected to be of a type translatable to the SQL type the procedure expects. For output parameters, any JavaScript value can be passed in, and will be overwritten by the function. The number of parameters passed in must match the number of parameters expected by the procedure.
* **{OPTIONAL} callback**: The function called when `.callProcedure` has finished execution. If no callback function is given, `.callProcedure` will return a native JavaScript `Promise`. Callback signature is:
    * error: The error that occured in execution, or `null` if no error
    * result: The result object from execution

#### Examples:

**Promises**

```javascript
const { Connection } = require('odbc');
const connection = new Connection(`${process.env.CONNECTION_STRING}`);

// can only use await keywork in an async function
async function callProcedureExample() {
    const statement = await connection.createStatement();
    // now have a statement where sql can be prepared, bound, and executed
}

callProcedureExample();
```

**Callbacks**

```javascript
const { Connection } = require('odbc');
const connection = new Connection(connectionString);
connection.callProcedure(null, null, 'MY_PROC', [undefined], (error, result) => {
    if (error) { console.error(error) } // handle
    // result contains an array of results, and has a `parameters` property to access parameters returned by the procedure.
    console.log(result);
})
```

---

### `.createStatement(callback?)`

Returns a [Statement](#Statement) object from the connection.

#### Parameters:
* **{OPTIONAL} callback**: The function called when `.createStatement` has finished execution. If no callback function is given, `.createStatement` will return a native JavaScript `Promise`. Callback signature is:
    * error: The error that occured in execution, or `null` if no error
    * statement: The newly created Statement object

#### Examples:

**Promises**

```javascript
const { Connection } = require('odbc');
const connection = new Connection(`${process.env.CONNECTION_STRING}`);

// can only use await keywork in an async function
async function statementExample() {
    const statement = await connection.createStatement();
    // now have a statement where sql can be prepared, bound, and executed
}

statementExample();
```

**Callbacks**

```javascript
const { Connection } = require('odbc');
const connection = new Connection(`${process.env.CONNECTION_STRING}`);

// returns information about all tables in schema MY_SCHEMA
connection.createStatement((error, statement) => {
    if (error) { return; } // handle
    // now have a statement where sql can be prepared, bound, and executed
});
```

---
>>>>>>> 58a1effa50203f86a7746d01f43b9a5bf21d973d

# set C++ build tools environment
npm install
```


### pull
```bash
# git update-index --assume-unchanged     README.md
# git update-index --no-assume-unchanged  README.md

# odbc v2
git pull https://github.com/wankdanker/node-odbc.git v2.0

```